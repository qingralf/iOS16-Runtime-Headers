/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/InstalledContentLibrary.framework/InstalledContentLibrary
 */

@interface MIContainer : NSObject {
    struct container_object_s { } * _container;
    unsigned long long  _containerClass;
    NSURL * _containerURL;
    unsigned long long  _diskUsage;
    NSString * _identifier;
    bool  _isTransient;
    NSString * _personaUniqueString;
    unsigned long long  _status;
}

@property (nonatomic, readonly) struct container_object_s { }*container;
@property (nonatomic) unsigned long long containerClass;
@property (nonatomic, readonly) NSURL *containerURL;
@property (nonatomic, readonly) NSString *debugDescriptionForContainer;
@property (nonatomic) unsigned long long diskUsage;
@property (nonatomic, retain) NSString *identifier;
@property (nonatomic, readonly) bool isTransient;
@property (nonatomic, readonly) NSString *personaUniqueString;
@property (nonatomic) unsigned long long status;

+ (id)_bundleContainerForIdentifier:(id)arg1 error:(id*)arg2;
+ (struct container_object_s { }*)_containerForIdentifier:(id)arg1 ofContentClass:(unsigned long long)arg2 forPersona:(id)arg3 transient:(bool)arg4 create:(bool)arg5 created:(bool*)arg6 error:(id*)arg7;
+ (id)_containersForIdentifier:(id)arg1 groupContainerIdentifier:(id)arg2 ofContentClass:(unsigned long long)arg3 forPersona:(id)arg4 error:(id*)arg5;
+ (bool)_deleteContainers:(struct container_object_s {}**)arg1 count:(unsigned long long)arg2 waitForDeletion:(bool)arg3 error:(id*)arg4;
+ (id)allContainersForIdentifier:(id)arg1 options:(unsigned long long)arg2 error:(id*)arg3;
+ (id)containerWithIdentifier:(id)arg1 ofContentClass:(unsigned long long)arg2 createIfNeeded:(bool)arg3 created:(bool*)arg4 error:(id*)arg5;
+ (id)containersWithClass:(unsigned long long)arg1 error:(id*)arg2;
+ (id)containersWithClass:(unsigned long long)arg1 personaUniqueString:(id)arg2 error:(id*)arg3;
+ (id)groupContainerURLsForBundleIdentifier:(id)arg1 persona:(id)arg2 error:(id*)arg3;
+ (bool)removeContainers:(id)arg1 waitForDeletion:(bool)arg2 error:(id*)arg3;
+ (id)tempContainerWithIdentifier:(id)arg1 ofContentClass:(unsigned long long)arg2 error:(id*)arg3;

- (void).cxx_destruct;
- (bool)_refreshContainerMetadataWithError:(id*)arg1;
- (bool)_replaceExistingContainer:(id)arg1 replacementReason:(unsigned long long)arg2 waitForDeletion:(bool)arg3 error:(id*)arg4;
- (bool)_setContainer:(struct container_object_s { }*)arg1 error:(id*)arg2;
- (bool)captureStoreDataFromDirectory:(id)arg1 doCopy:(bool)arg2 failureIsFatal:(bool)arg3 withError:(id*)arg4;
- (struct container_object_s { }*)container;
- (unsigned long long)containerClass;
- (id)containerURL;
- (void)dealloc;
- (id)debugDescriptionForContainer;
- (id)description;
- (unsigned long long)diskUsage;
- (id)identifier;
- (id)infoValueForKey:(id)arg1 error:(id*)arg2;
- (id)initWithContainer:(struct container_object_s { }*)arg1 error:(id*)arg2;
- (id)initWithContainerURL:(id)arg1;
- (bool)isTransient;
- (bool)makeContainerLiveReplacingContainer:(id)arg1 reason:(unsigned long long)arg2 waitForDeletion:(bool)arg3 withError:(id*)arg4;
- (bool)makeContainerLiveWithError:(id*)arg1;
- (id)personaUniqueString;
- (bool)purgeContentWithError:(id*)arg1;
- (bool)recreateDefaultStructureWithError:(id*)arg1;
- (bool)regenerateDirectoryUUIDWithError:(id*)arg1;
- (bool)removeUnderlyingContainerWaitingForDeletion:(bool)arg1 error:(id*)arg2;
- (void)setContainerClass:(unsigned long long)arg1;
- (void)setDiskUsage:(unsigned long long)arg1;
- (void)setIdentifier:(id)arg1;
- (bool)setInfoValue:(id)arg1 forKey:(id)arg2 error:(id*)arg3;
- (void)setStatus:(unsigned long long)arg1;
- (unsigned long long)status;

@end
