/* Generated by RuntimeBrowser
   Image: /System/Library/Frameworks/CoreImage.framework/CoreImage
 */

@interface InpaintingImageHelpers : NSObject

+ (id)absoluteDiffBetweenImage:(id)arg1 andImage:(id)arg2;
+ (id)blendImage:(id)arg1 withBackgroundImage:(id)arg2 usingMask:(id)arg3;
+ (id)blendImage:(id)arg1 withBackgroundImage:(id)arg2 usingMask:(id)arg3 andGaussianBlendRadius:(int)arg4;
+ (id)blurImage:(id)arg1 withSigma:(double)arg2;
+ (id)compositeImage:(id)arg1 overImage:(id)arg2;
+ (id)compositeImageNoReclamping:(id)arg1 overImage:(id)arg2;
+ (id)compositeImageWithReclamping:(id)arg1 overImage:(id)arg2;
+ (id)computePerChannelAvgPixelValueInImage:(id)arg1 onArea:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2;
+ (id)computePerChannelSumsOfPixelsInImage:(id)arg1 onArea:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })computeTileRectForImage:(id)arg1 aroundCenterPoint:(struct CGPoint { double x1; double x2; })arg2 tileSize:(int)arg3;
+ (id)createBGRAVImageWrapperFromCIImage:(id)arg1;
+ (id)dilateMask:(id)arg1 usingRadius:(int)arg2;
+ (id)dilateMaskUsingClampingAndCropping:(id)arg1 usingRadius:(int)arg2;
+ (id)erodeMask:(id)arg1 usingRadius:(int)arg2;
+ (id)erodeMaskUsingClampingAndCropping:(id)arg1 usingRadius:(int)arg2;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })expandBoundingBox:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 toWidth:(int)arg2 andHeight:(int)arg3 withinArea:(struct CGSize { double x1; double x2; })arg4;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })expandBoundingBox:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 withSideExtraPercentage:(float)arg2 maxExtraSidePixels:(int)arg3 withinArea:(struct CGSize { double x1; double x2; })arg4;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })expandBoundingBoxToRectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 withSideExtraPercentage:(float)arg2 maxExtraSidePixels:(int)arg3 withinArea:(struct CGSize { double x1; double x2; })arg4 roundUpSidesToClosestResolution:(id)arg5;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })expandBoundingBoxToSquare:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 withSideExtraPercentage:(float)arg2 maxExtraSidePixels:(int)arg3 withinArea:(struct CGSize { double x1; double x2; })arg4 roundUpSidesToClosestResolution:(id)arg5;
+ (double)expandDimension:(double)arg1 toOneOfTheResolutions:(id)arg2;
+ (id)extractTileFromImage:(id)arg1 aroundCenterPoint:(struct CGPoint { double x1; double x2; })arg2 tileSize:(int)arg3;
+ (id)findEquidistantPointsOnMaskDiagonal:(id)arg1 tileSize:(int)arg2 maxDistanceBetweenPoints:(int)arg3 diagonalityDirection:(int)arg4;
+ (int)findTile1DOffsetForCenter:(int)arg1 maxBound:(int)arg2 tileSize:(int)arg3;
+ (id)invertMask:(id)arg1;
+ (id)moveOriginForImage:(id)arg1 to:(struct CGPoint { double x1; double x2; })arg2;
+ (id)multiplyImage:(id)arg1 withMask:(id)arg2;
+ (id)padImage:(id)arg1 toExtent:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2 usingColor:(id)arg3;
+ (id)padMask:(id)arg1 toImageSize:(id)arg2;
+ (id)reclampImageWith1PixBoundary:(id)arg1;
+ (void)saveCIImage:(id)arg1 asPNGAt:(id)arg2;
+ (void)saveCIImage:(id)arg1 asTIFFAt:(id)arg2;
+ (void)saveVImageWrapper:(id)arg1 asPNGAt:(id)arg2;
+ (id)scaleImage:(id)arg1 toShorterEdgeSize:(double)arg2;
+ (id)scaleImage:(id)arg1 toSize:(struct CGSize { double x1; double x2; })arg2;
+ (id)scaleImage:(id)arg1 toWidth:(double)arg2 andHeight:(double)arg3;
+ (id)thresholdMask:(id)arg1;

@end
