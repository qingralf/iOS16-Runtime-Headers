/* Generated by RuntimeBrowser
   Image: /System/Library/Frameworks/MetalPerformanceShadersGraph.framework/MetalPerformanceShadersGraph
 */

@interface MPSGraphExecutable : NSObject {
    bool  _briefProfilingOpNames;
    void * _builder;
    unsigned long long  _compilationID;
    NSObject<OS_dispatch_queue> * _concurrentDispatchQueue;
    NSString * _dumpCompiledProductsPath;
    bool  _enableCommitAndContinue;
    bool  _enableProfilingOpNames;
    unsigned long long  _evDumpModuleFlag;
    NSString * _evDumpModulePath;
    struct shared_ptr<mlir::MLIRContext> { 
        struct MLIRContext {} *__ptr_; 
        struct __shared_weak_count {} *__cntrl_; 
    }  _executableContext;
    struct _opaque_pthread_mutex_t { 
        long long __sig; 
        BOOL __opaque[56]; 
    }  _executableMutex;
    NSArray * _feedTensorArray;
    NSDictionary * _feeds;
    NSFileManager * _fileManager;
    bool  _forceANERuntimeHack;
    unsigned long long  _forcePlacementOnDevice;
    MPSGraph * _graph;
    NSString * _modelFileArchivePath;
    unsigned long long  _modelUID;
    struct unordered_map<std::string, std::unique_ptr<BaseRuntime>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, std::unique_ptr<BaseRuntime>>>> { 
        struct __hash_table<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, std::hash<std::string>, std::equal_to<std::string>, true>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, std::equal_to<std::string>, std::hash<std::string>, true>, std::allocator<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>>> { 
            struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *> *>>> { 
                struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *> *>>> { 
                    void **__value_; 
                    struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *> *>> { 
                        struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *> *>> { 
                            unsigned long long __value_; 
                        } __data_; 
                    } __value_; 
                } __ptr_; 
            } __bucket_list_; 
            struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *>>> { 
                struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, void *> *> { 
                    void *__next_; 
                } __value_; 
            } __p1_; 
            struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, std::hash<std::string>, std::equal_to<std::string>, true>> { 
                unsigned long long __value_; 
            } __p2_; 
            struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::unique_ptr<BaseRuntime>>, std::equal_to<std::string>, std::hash<std::string>, true>> { 
                float __value_; 
            } __p3_; 
        } __table_; 
    }  _newRuntimeCache;
    bool  _oldCostModelPass;
    struct unordered_map<std::string, mlir::OwningOpRef<mlir::ModuleOp>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, mlir::OwningOpRef<mlir::ModuleOp>>>> { 
        struct __hash_table<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::hash<std::string>, std::equal_to<std::string>, true>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::equal_to<std::string>, std::hash<std::string>, true>, std::allocator<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>>> { 
            struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>>> { 
                struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>>> { 
                    void **__value_; 
                    struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>> { 
                        struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>> { 
                            unsigned long long __value_; 
                        } __data_; 
                    } __value_; 
                } __ptr_; 
            } __bucket_list_; 
            struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *>>> { 
                struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> { 
                    void *__next_; 
                } __value_; 
            } __p1_; 
            struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::hash<std::string>, std::equal_to<std::string>, true>> { 
                unsigned long long __value_; 
            } __p2_; 
            struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::equal_to<std::string>, std::hash<std::string>, true>> { 
                float __value_; 
            } __p3_; 
        } __table_; 
    }  _optimizedModuleCache;
    struct unordered_map<std::string, mlir::OwningOpRef<mlir::ModuleOp>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, mlir::OwningOpRef<mlir::ModuleOp>>>> { 
        struct __hash_table<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::hash<std::string>, std::equal_to<std::string>, true>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::equal_to<std::string>, std::hash<std::string>, true>, std::allocator<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>>> { 
            struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>>> { 
                struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>>> { 
                    void **__value_; 
                    struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>> { 
                        struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> *>> { 
                            unsigned long long __value_; 
                        } __data_; 
                    } __value_; 
                } __ptr_; 
            } __bucket_list_; 
            struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *>>> { 
                struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, void *> *> { 
                    void *__next_; 
                } __value_; 
            } __p1_; 
            struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::hash<std::string>, std::equal_to<std::string>, true>> { 
                unsigned long long __value_; 
            } __p2_; 
            struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, mlir::OwningOpRef<mlir::ModuleOp>>, std::equal_to<std::string>, std::hash<std::string>, true>> { 
                float __value_; 
            } __p3_; 
        } __table_; 
    }  _optimizedNoDeviceModuleCache;
    unsigned long long  _options;
    MPSGraphCompilationDescriptor * _originalCompilationDescriptor;
    struct OwningOpRef<mlir::ModuleOp> { 
        struct ModuleOp { 
            struct Operation {} *state; 
        } op; 
    }  _originalModule;
    bool  _printANEPlacementAnalysis;
    bool  _printCostModel;
    bool  _runPlacementPass;
    struct unordered_map<std::string, std::unique_ptr<GPURuntime>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, std::unique_ptr<GPURuntime>>>> { 
        struct __hash_table<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, std::hash<std::string>, std::equal_to<std::string>, true>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, std::equal_to<std::string>, std::hash<std::string>, true>, std::allocator<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>>> { 
            struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *> *>>> { 
                struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *> *>>> { 
                    void **__value_; 
                    struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *> *>> { 
                        struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *> *>> { 
                            unsigned long long __value_; 
                        } __data_; 
                    } __value_; 
                } __ptr_; 
            } __bucket_list_; 
            struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *>>> { 
                struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, void *> *> { 
                    void *__next_; 
                } __value_; 
            } __p1_; 
            struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, std::hash<std::string>, std::equal_to<std::string>, true>> { 
                unsigned long long __value_; 
            } __p2_; 
            struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::unique_ptr<GPURuntime>>, std::equal_to<std::string>, std::hash<std::string>, true>> { 
                float __value_; 
            } __p3_; 
        } __table_; 
    }  _runtimeCache;
    unsigned long long  _sharedEventSignalValue;
    void * _symbolTable;
    NSArray * _targetOperations;
    NSArray * _targetTensorArray;
    bool  _useCostModel;
    bool  _useScratchPadContext;
}

@property (readonly) NSArray *feedTensors;
@property unsigned long long options;
@property (readonly) NSArray *targetTensors;

+ (id)executablesWithMLIRSourceForMultipleModules:(id)arg1 executableDescriptor:(id)arg2 regionNames:(id)arg3;

- (id).cxx_construct;
- (void).cxx_destruct;
- (id)allocateTensorDataTargetsForDevice:(id)arg1 inputsArray:(id)arg2;
- (struct OwningOpRef<mlir::ModuleOp> { struct ModuleOp { struct Operation {} *x_1_1_1; } x1; })cloneForFeeds:(id)arg1 targetTensors:(id)arg2 targetOperations:(id)arg3;
- (void)commonPostInit:(void*)arg1;
- (void)commonPreInitWithDescriptor:(id)arg1;
- (void)dealloc;
- (id)debugDescription;
- (void)dump;
- (id)emitObjCToURL:(id)arg1 test:(bool)arg2;
- (id)encodeToCommandBuffer:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)encodeWithMPSCommandBuffer:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)feedTensors;
- (void)fileBackModule:(const void*)arg1 withPath:(id)arg2;
- (id)getIR;
- (id)getInputShapes;
- (void*)getNewRuntimeForDevice:(id)arg1 module:(struct ModuleOp { struct Operation {} *x1; })arg2;
- (id)getOperationsToVisitForOperation:(id)arg1 visitedOperations:(id)arg2;
- (id)getOutputShapes;
- (id)getTargetShapesForDevice:(id)arg1 inputsArray:(id)arg2;
- (id)getTensorDataArraysWithDevice:(id)arg1 feedsDictionary:(id)arg2 resultsDictionary:(id)arg3 inputsArray:(id)arg4 resultsArray:(id)arg5;
- (id)initWithCoreMLPackage:(id)arg1 executableDescriptor:(id)arg2;
- (id)initWithGraph:(id)arg1 device:(id)arg2 feeds:(id)arg3 targetTensors:(id)arg4 targetOperations:(id)arg5 executableDescriptor:(id)arg6;
- (id)initWithMILProgram:(void*)arg1 executableDescriptor:(id)arg2;
- (id)initWithMILProgramWithURL:(id)arg1 executableDescriptor:(id)arg2;
- (id)initWithMLIRModule:(struct ModuleOp { struct Operation {} *x1; })arg1 executableDescriptor:(id)arg2;
- (id)initWithMLIRSource:(id)arg1 executableDescriptor:(id)arg2;
- (id)initWithMLIRSourceFromURL:(id)arg1 executableDescriptor:(id)arg2;
- (void)initializeMLIR;
- (id)initializeWithMLIRModule:(struct ModuleOp { struct Operation {} *x1; })arg1 executableDescriptor:(id)arg2;
- (bool)isExecutableForFeeds:(id)arg1 targetTensors:(id)arg2 targetOperations:(id)arg3 compilationDescriptor:(id)arg4;
- (struct OwningOpRef<mlir::ModuleOp> { struct ModuleOp { struct Operation {} *x_1_1_1; } x1; })optimizationPassesWithDevice:(id)arg1 sourceModule:(void*)arg2 fileToStoreName:(id)arg3 compilationDescriptor:(id)arg4;
- (unsigned long long)options;
- (id)runAsyncWithCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runAsyncWithDevice:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runAsyncWithMTLCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runInternalWithDevice:(id)arg1 commandBuffer:(id)arg2 feeds:(id)arg3 results:(id)arg4 executableExecutionDescriptor:(id)arg5 mpsGraphOwnedCommandBuffer:(bool)arg6;
- (id)runInternalWithDevice:(id)arg1 commandBuffer:(id)arg2 feedsDictionary:(id)arg3 resultsDictionary:(id)arg4 executableExecutionDescriptor:(id)arg5 mpsGraphOwnedCommandBuffer:(bool)arg6;
- (id)runWithDevice:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runWithMTLCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3;
- (id)runWithMTLCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (void)sanitizeExternalModuleWithVariableFetchHandler:(id /* block */)arg1;
- (void)setOptions:(unsigned long long)arg1;
- (void)specializeWithDevice:(id)arg1 inputShapes:(id)arg2 compilationDescriptor:(id)arg3;
- (void)specializeWithDevice:(id)arg1 inputTypes:(id)arg2 compilationDescriptor:(id)arg3;
- (struct ModuleOp { struct Operation {} *x1; })specializeWithDevice:(id)arg1 inputsArray:(id)arg2 compilationDescriptor:(id)arg3;
- (struct ModuleOp { struct Operation {} *x1; })specializedModuleWithDevice:(id)arg1 inputShapes:(id)arg2 compilationDescriptor:(id)arg3;
- (id)targetTensors;

@end
